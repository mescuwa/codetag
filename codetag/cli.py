# FILE: codetag/cli.py

import json
import time
import os
from pathlib import Path
from typing import List, Dict, Optional, Any, Set, Tuple

import typer
from pydantic import BaseModel, Field
from .models import AnalysisReport  # Centralized data models
from . import __version__  # Canonical package version

# --- In-package imports ---
from .fs_tree import FsNode, build_fs_tree
# distill_level helpers are now encapsulated in distiller.distill_repository
from .packer import pack_repository
from .auditor import audit_repository
from .config import load_config, get_scan_exclusions
from .tui import run_tui
from .distiller import distill_repository

try:
    from .tree_sitter_distiller import distill_with_tree_sitter, TREE_SITTER_AVAILABLE
except ImportError:
    TREE_SITTER_AVAILABLE = False
    distill_with_tree_sitter = None

# --- Constants ---
CODETAG_MARKER = "# -- GENERATED BY CODETAG --"

# Pydantic models have been centralized in codetag.models


# Placeholder removed ‚Äì real TUI lives in codetag.tui.run_tui


# --- CLI Application Setup ---

def version_callback(value: bool):
    if value:
        typer.echo(f"CodeTag Version: {__version__}\nMade by Lumina Mescuwa (@mescuwa)")
        raise typer.Exit()

# NEW: We create a Typer app with `no_args_is_help=False` so we can handle the no-argument case.
app = typer.Typer(
    name="codetag",
    help=(
        "Analyze, pack, and distill codebases for AI and human understanding.\n\n"
        "Made by Lumina Mescuwa (@mescuwa) ‚Äî https://github.com/mescuwa"
    ),
    context_settings={"help_option_names": ["-h", "--help"]},
    no_args_is_help=False,  # This is crucial!
    invoke_without_command=True,  # Allows the root command to run logic
)

@app.callback()
def main(
    ctx: typer.Context,  # Context object to see if a subcommand was invoked
    version: Optional[bool] = typer.Option(
        None,
        "--version",
        "-v",
        help="Show the application's version and exit.",
        callback=version_callback,
        is_eager=True,
    ),
):
    """
    CodeTag: Analyze, pack, and distill codebases.
    If no command is specified, launches the interactive TUI.
    """
    # If a subcommand is about to run, `invoked_subcommand` will be its name.
    # If no subcommand is given, it's None.
    if ctx.invoked_subcommand is None:
        run_tui()

# --- Subcommands ---

@app.command(name="scan")
def scan_repository(
    # ... (arguments are exactly the same as before)
    path: Path = typer.Argument(..., exists=True, resolve_path=True, help="Directory to analyze."),
    include_hidden: bool = typer.Option(False, "-i", "--include-hidden", help="Include hidden files and directories."),
    output_file: Optional[Path] = typer.Option(None, "-o", "--output", help="Save the JSON report to a file instead of stdout."),
    rules: Optional[Path] = typer.Option(None, "--rules", help="Path to a custom rules.yaml file.", exists=True, resolve_path=True),
    no_cache: bool = typer.Option(False, "--no-cache", help="Disable on-disk caching for faster re-scans."),
    exclude_dirs: Optional[str] = typer.Option(None, "--exclude-dirs", help="Comma-separated list of directories to exclude."),
    exclude_patterns: Optional[str] = typer.Option(None, "--exclude-patterns", help="Comma-separated list of glob patterns for files to exclude."),
):
    """Analyze a repository and create a comprehensive JSON report."""
    start = time.time()
    typer.echo(f"üîç Analyzing repository at: {path}", err=True)

    config = load_config(path)
    exclusions = get_scan_exclusions(config, exclude_dirs, exclude_patterns)

    MAX_FILES = int(os.getenv("CODETAG_MAX_FILES", "5000"))
    try:
        from .analyzer import run_analysis
        report = run_analysis(
            path,
            include_hidden,
            MAX_FILES,
            rules_path=rules,
            use_cache=not no_cache,
            exclude_dirs=exclusions["exclude_dirs"],
            exclude_patterns=exclusions["exclude_patterns"],
        )
    except ValueError as e:
        typer.echo(f"‚ùå Error: {e}", err=True)
        raise typer.Exit(code=1)

    if report.threat_assessment.secrets_found:
        typer.echo(
            f"üö® WARNING: Found {len(report.threat_assessment.secrets_found)} potential secret(s).",
            err=True,
            color=typer.colors.RED,
        )

    out_json = report.model_dump_json(indent=2)
    if output_file:
        output_file.write_text(out_json)
        typer.echo(f"‚úÖ Report saved to: {output_file}", err=True)
    else:
        print(out_json)

# --- (The pack, distill, and audit commands follow the same pattern) ---

@app.command()
def pack(
    # ... (arguments are exactly the same as before)
    path: Path = typer.Argument(..., exists=True, resolve_path=True, help="Directory to pack."),
    output_file: Path = typer.Option("packed_code.txt", "-o", "--output", help="Path to save the packed text file."),
    max_file_size_kb: int = typer.Option(100, help="Maximum size (in KB) of a single file to include."),
    exclude_extensions: str = typer.Option("", help="Comma-separated list of additional file extensions to exclude."),
    max_tokens: int = typer.Option(250_000, "--max-tokens", "-t", help="The maximum total number of tokens for the packed output."),
    format: str = typer.Option("raw", "--format", help="Output format: 'raw' or 'json'."),
):
    """Pack source code into a single file for raw context stuffing."""
    typer.echo(f"üì¶ Packing repository at: {path}", err=True)
    try:
        exclude_set = {
            ext.strip().lower() if ext.strip().startswith('.') else f".{ext.strip().lower()}"
            for ext in exclude_extensions.split(',') if ext.strip()
        } if exclude_extensions else set()

        stats = pack_repository(
            path=path,
            output_file=output_file,
            max_tokens=max_tokens,
            max_file_size_kb=max_file_size_kb,
            exclude_extensions=exclude_set,
            output_format=format,
        )
        typer.echo(
            f"‚úÖ Packed {stats['files_selected']} files (~{stats['final_token_count']:,} tokens) into {output_file} in {stats['duration_seconds']}s.",
            err=True,
            color=typer.colors.GREEN,
        )
    except Exception as e:
        typer.echo(f"‚ùå Error: {e}", err=True)
        raise typer.Exit(code=1)


@app.command()
def distill(
    path: Path = typer.Argument(..., exists=True, resolve_path=True, help="Directory to distill."),
    output_file: Path = typer.Option("distilled.txt", "-o", "--output-file", help="Path to save the distilled context file."),
    level: int = typer.Option(2, "--level", "-l", min=1, max=2, help="Distillation level (1: cleanup, 2: structural)."),
    anchors: bool = typer.Option(True, "--anchors/--no-anchors", help="Include SHA-256 anchors for stripped Python function bodies."),
):
    """Distill a codebase into a concise, LLM-friendly summary."""

    typer.echo(f"üíß Distilling codebase at: {path} (Level {level})", err=True)
    try:
        stats = distill_repository(
            path=path,
            output_file=output_file,
            level=level,
            anchors=anchors,
        )
        typer.echo(
            f"‚úÖ Distilled {stats['files_processed']} files to ~{stats['total_tokens']:,} tokens into {output_file} in {stats['duration_seconds']}s.",
            err=True,
        )
        typer.echo(f"üó∫Ô∏è  Source map saved to {stats['map_file_path']}", err=True)
    except Exception as exc:
        typer.echo(f"‚ùå Error during distillation: {exc}", err=True)
        raise typer.Exit(code=1)


@app.command()
def audit(
    # ... (arguments are exactly the same as before)
    path: Path = typer.Argument(..., exists=True, resolve_path=True, help="Path to the project directory to audit."),
    strict: bool = typer.Option(False, "--strict", help="Use a stricter community ruleset for Semgrep."),
):
    """Audit a project for threats using OSV-Scanner and Semgrep."""
    assessment = audit_repository(path, strict_semgrep=strict)
    has_findings = bool(
        assessment.dependency_vulnerabilities
        or assessment.code_vulnerabilities
        or assessment.secrets_found
    )
    if has_findings:
        typer.secho("Audit finished: Found potential issues.", fg=typer.colors.YELLOW, err=True)
        raise typer.Exit(code=1)
    else:
        typer.secho("‚úÖ Audit finished: No issues found.", fg=typer.colors.GREEN, err=True)

if __name__ == "__main__":
    app() 