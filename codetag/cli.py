# FILE: codetag/cli.py

import os
from pathlib import Path
from typing import Optional

import typer
from . import __version__  # Canonical package version

# --- In-package imports ---
# distill_level helpers are now encapsulated in distiller.distill_repository
from .packer import pack_repository
from .auditor import audit_repository
from rich.table import Table
from rich.console import Console
from .config import load_config, get_scan_exclusions
from .tui import run_tui
from .distiller import distill_repository

try:
    from .tree_sitter_distiller import distill_with_tree_sitter, TREE_SITTER_AVAILABLE
except ImportError:
    TREE_SITTER_AVAILABLE = False
    distill_with_tree_sitter = None

# --- Constants ---
CODETAG_MARKER = "# -- GENERATED BY CODETAG --"

# Pydantic models have been centralized in codetag.models


# Placeholder removed â€“ real TUI lives in codetag.tui.run_tui


# --- CLI Application Setup ---

def version_callback(value: bool):
    if value:
        typer.echo(f"CodeTag Version: {__version__}\nMade by Lumina Mescuwa (@mescuwa)")
        raise typer.Exit()

# NEW: We create a Typer app with `no_args_is_help=False` so we can handle the no-argument case.
app = typer.Typer(
    name="codetag",
    help=(
        "Analyze, pack, and distill codebases for AI and human understanding.\n\n"
        "Made by Lumina Mescuwa (@mescuwa) â€” https://github.com/mescuwa"
    ),
    context_settings={"help_option_names": ["-h", "--help"]},
    no_args_is_help=False,  # This is crucial!
    invoke_without_command=True,  # Allows the root command to run logic
)

@app.callback()
def main(
    ctx: typer.Context,  # Context object to see if a subcommand was invoked
    version: Optional[bool] = typer.Option(
        None,
        "--version",
        "-v",
        help="Show the application's version and exit.",
        callback=version_callback,
        is_eager=True,
    ),
):
    """
    CodeTag: Analyze, pack, and distill codebases.
    If no command is specified, launches the interactive TUI.
    """
    # If a subcommand is about to run, `invoked_subcommand` will be its name.
    # If no subcommand is given, it's None.
    if ctx.invoked_subcommand is None:
        run_tui()

# --- Subcommands ---

@app.command(name="scan")
def scan_repository(
    # ... (arguments are exactly the same as before)
    path: Path = typer.Argument(..., exists=True, resolve_path=True, help="Directory to analyze."),
    include_hidden: bool = typer.Option(False, "-i", "--include-hidden", help="Include hidden files and directories."),
    output_file: Optional[Path] = typer.Option(None, "-o", "--output", help="Save the JSON report to a file instead of stdout."),
    rules: Optional[Path] = typer.Option(None, "--rules", help="Path to a custom rules.yaml file.", exists=True, resolve_path=True),
    no_cache: bool = typer.Option(False, "--no-cache", help="Disable on-disk caching for faster re-scans."),
    exclude_dirs: Optional[str] = typer.Option(None, "--exclude-dirs", help="Comma-separated list of directories to exclude."),
    exclude_patterns: Optional[str] = typer.Option(None, "--exclude-patterns", help="Comma-separated list of glob patterns for files to exclude."),
):
    """Analyze a repository and create a comprehensive JSON report."""
    # timer removed (variable unused)
    typer.echo(f"ðŸ” Analyzing repository at: {path}", err=True)

    config = load_config(path)
    exclusions = get_scan_exclusions(config, exclude_dirs, exclude_patterns)

    MAX_FILES = int(os.getenv("CODETAG_MAX_FILES", "5000"))
    try:
        from .analyzer import run_analysis
        report = run_analysis(
            path,
            include_hidden,
            MAX_FILES,
            rules_path=rules,
            use_cache=not no_cache,
            exclude_dirs=exclusions["exclude_dirs"],
            exclude_patterns=exclusions["exclude_patterns"],
        )
    except ValueError as e:
        typer.echo(f"âŒ Error: {e}", err=True)
        raise typer.Exit(code=1)

    if report.threat_assessment.secrets_found:
        typer.echo(
            f"ðŸš¨ WARNING: Found {len(report.threat_assessment.secrets_found)} potential secret(s).",
            err=True,
            color=typer.colors.RED,
        )

    out_json = report.model_dump_json(indent=2)
    if output_file:
        output_file.write_text(out_json)
        typer.echo(f"âœ… Report saved to: {output_file}", err=True)
    else:
        print(out_json)

# --- (The pack, distill, and audit commands follow the same pattern) ---

@app.command()
def pack(
    # ... (arguments are exactly the same as before)
    path: Path = typer.Argument(..., exists=True, resolve_path=True, help="Directory to pack."),
    output_file: Path = typer.Option("packed_code.txt", "-o", "--output", help="Path to save the packed text file."),
    max_file_size_kb: int = typer.Option(100, help="Maximum size (in KB) of a single file to include."),
    exclude_extensions: str = typer.Option("", help="Comma-separated list of additional file extensions to exclude."),
    max_tokens: int = typer.Option(250_000, "--max-tokens", "-t", help="The maximum total number of tokens for the packed output."),
    format: str = typer.Option("raw", "--format", help="Output format: 'raw' or 'json'."),
):
    """Pack source code into a single file for raw context stuffing."""
    typer.echo(f"ðŸ“¦ Packing repository at: {path}", err=True)
    try:
        exclude_set = {
            ext.strip().lower() if ext.strip().startswith('.') else f".{ext.strip().lower()}"
            for ext in exclude_extensions.split(',') if ext.strip()
        } if exclude_extensions else set()

        stats = pack_repository(
            path=path,
            output_file=output_file,
            max_tokens=max_tokens,
            max_file_size_kb=max_file_size_kb,
            exclude_extensions=exclude_set,
            output_format=format,
        )
        typer.echo(
            f"âœ… Packed {stats['files_selected']} files (~{stats['final_token_count']:,} tokens) into {output_file} in {stats['duration_seconds']}s.",
            err=True,
            color=typer.colors.GREEN,
        )
    except Exception as e:
        typer.echo(f"âŒ Error: {e}", err=True)
        raise typer.Exit(code=1)


@app.command()
def distill(
    path: Path = typer.Argument(..., exists=True, resolve_path=True, help="Directory to distill."),
    output_file: Path = typer.Option("distilled.txt", "-o", "--output-file", help="Path to save the distilled context file."),
    level: int = typer.Option(2, "--level", "-l", min=1, max=2, help="Distillation level (1: cleanup, 2: structural)."),
    anchors: bool = typer.Option(True, "--anchors/--no-anchors", help="Include SHA-256 anchors for stripped Python function bodies."),
):
    """Distill a codebase into a concise, LLM-friendly summary."""

    typer.echo(f"ðŸ’§ Distilling codebase at: {path} (Level {level})", err=True)
    try:
        stats = distill_repository(
            path=path,
            output_file=output_file,
            level=level,
            anchors=anchors,
        )
        typer.echo(
            f"âœ… Distilled {stats['files_processed']} files to ~{stats['total_tokens']:,} tokens into {output_file} in {stats['duration_seconds']}s.",
            err=True,
        )
        typer.echo(f"ðŸ—ºï¸  Source map saved to {stats['map_file_path']}", err=True)
    except Exception as exc:
        typer.echo(f"âŒ Error during distillation: {exc}", err=True)
        raise typer.Exit(code=1)


@app.command()
def audit(
    # ... (arguments are exactly the same as before)
    path: Path = typer.Argument(..., exists=True, resolve_path=True, help="Path to the project directory to audit."),
    strict: bool = typer.Option(False, "--strict", help="Use a stricter community ruleset for Semgrep."),
):
    """Audit a project for threats using OSV-Scanner and Semgrep."""
    assessment = audit_repository(path, strict_semgrep=strict)

    console = Console(stderr=True)

    if assessment.dependency_vulnerabilities:
        tbl = Table(title="Dependency Vulnerabilities", show_lines=True)
        tbl.add_column("ID", style="bold red")
        tbl.add_column("Package")
        tbl.add_column("Version")
        tbl.add_column("Severity", justify="center")
        tbl.add_column("Summary")
        for v in assessment.dependency_vulnerabilities:
            tbl.add_row(v.id, v.package_name, v.vulnerable_version, v.severity or "?", v.summary[:60] + ("â€¦" if len(v.summary) > 60 else ""))
        console.print(tbl)

    if assessment.code_vulnerabilities:
        tbl = Table(title="Code Vulnerabilities", show_lines=True)
        tbl.add_column("Check ID", style="bold red")
        tbl.add_column("File")
        tbl.add_column("Line", justify="right")
        tbl.add_column("Severity", justify="center")
        tbl.add_column("Message")
        for v in assessment.code_vulnerabilities:
            tbl.add_row(v.check_id, v.path, str(v.line), v.severity, v.message[:60] + ("â€¦" if len(v.message) > 60 else ""))
        console.print(tbl)

    if assessment.secrets_found:
        tbl = Table(title="Potential Secrets", show_lines=True)
        tbl.add_column("File")
        tbl.add_column("Line", justify="right")
        tbl.add_column("Type")
        tbl.add_column("Snippet")
        for s in assessment.secrets_found:
            tbl.add_row(s.file_path, str(s.line_number), s.secret_type, s.line_content)
        console.print(tbl)

    has_findings = bool(
        assessment.dependency_vulnerabilities
        or assessment.code_vulnerabilities
        or assessment.secrets_found
    )
    if has_findings:
        typer.secho("Audit finished: Found potential issues.", fg=typer.colors.YELLOW, err=True)
        raise typer.Exit(code=1)
    else:
        typer.secho("âœ… Audit finished: No issues found.", fg=typer.colors.GREEN, err=True)

if __name__ == "__main__":
    app() 