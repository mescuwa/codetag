"""Repository distillation utilities for CodeTag.

This module provides two levels of distillation for individual source files as
well as a high-level `distill_repository` helper that walks the project tree
and writes a single packed summary plus a JSON map of distilled ranges.
"""

from __future__ import annotations

import ast
import hashlib
import json
import re
import time
from pathlib import Path
from typing import Any, Dict, List, Optional

import tiktoken

from .fs_tree import build_fs_tree, flatten_fs_tree
from .language_stats import SOURCE_CODE_EXTENSIONS  # shared constant

# ---------------------------------------------------------------------------
# Optional Tree-sitter backend
# ---------------------------------------------------------------------------
try:
    from .tree_sitter_distiller import distill_with_tree_sitter, TREE_SITTER_AVAILABLE
except ImportError:  # pragma: no cover – optional dependency
    TREE_SITTER_AVAILABLE = False
    distill_with_tree_sitter = None  # type: ignore

# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

CODETAG_MARKER = "# -- GENERATED BY CODETAG --"

# ---------------------------------------------------------------------------
# Level-1 distillation – comment / docstring stripping
# ---------------------------------------------------------------------------


def distill_level_1(content: str) -> str:
    """Very light cleanup: strip comments, docstrings and excessive blank lines."""

    # 1. Remove single-line comments (`# ...`)
    content = re.sub(r"#.*$", "", content, flags=re.MULTILINE)

    # 2. Remove multi-line docstrings / block comments (naïve greedy regex)
    content = re.sub(r'"""[\s\S]*?"""', '"""..."""', content)
    content = re.sub(r"'''[\s\S]*?'''", "'''...'''", content)

    # 3. Collapse consecutive blank lines
    content = re.sub(r"(\n\s*){2,}", "\n\n", content)

    return content.strip()


# ---------------------------------------------------------------------------
# Level-2 distillation – structural AST transformation (Python-only)
# ---------------------------------------------------------------------------


class _StructureDistiller(ast.NodeTransformer):
    """Replace function / method bodies with ``pass`` keeping public interface."""

    def __init__(self, source_lines: List[str], *, include_anchors: bool = True):
        super().__init__()
        self._lines = source_lines
        self._include_anchors = include_anchors

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------
    def _hash_body(self, node: ast.AST) -> str:
        first = node.body[0].lineno - 1  # type: ignore[attr-defined]
        last_stmt = node.body[-1]  # type: ignore[index]
        last = getattr(last_stmt, "end_lineno", last_stmt.lineno) - 1
        segment = "\n".join(self._lines[first : last + 1])
        return hashlib.sha256(segment.encode()).hexdigest()

    def _strip(self, node: ast.AST):  # noqa: D401 – simple helper
        # Compute checksum before mutating body to preserve lineno attributes.
        body_hash = self._hash_body(node)

        # Replace implementation with a single `pass`
        node.body = [ast.Pass()]  # type: ignore[attr-defined]

        if not self._include_anchors:
            return node

        anchor = ast.Expr(value=ast.Constant(value=f"body-sha256: {body_hash}"))
        return [anchor, node]

    # ------------------------------------------------------------------
    # Visitors
    # ------------------------------------------------------------------
    def visit_FunctionDef(self, node):  # type: ignore[override]
        return self._strip(node)

    def visit_AsyncFunctionDef(self, node):  # type: ignore[override]
        return self._strip(node)

    def visit_ClassDef(self, node):  # type: ignore[override]
        self.generic_visit(node)
        return node


def distill_level_2(content: str, *, include_anchors: bool = True) -> str:
    """Preserve signatures and replace bodies with ``pass`` (Python-only)."""

    try:
        tree = ast.parse(content)
        distilled = _StructureDistiller(
            content.splitlines(), include_anchors=include_anchors
        ).visit(tree)
        ast.fix_missing_locations(distilled)
        code = ast.unparse(distilled)

        # Convert temporary string-literal anchors into real comments.
        code = re.sub(
            r"^(\s*)[\"']{1,3}body-sha256: ([0-9a-f]{64})[\"']{1,3}$",
            r"\1# body-sha256: \2",
            code,
            flags=re.MULTILINE,
        )
        return code
    except (SyntaxError, ValueError):
        # Invalid or non-Python input – fallback to level-1 cleanup.
        return distill_level_1(content)


# ---------------------------------------------------------------------------
# Repository-level helper
# ---------------------------------------------------------------------------


def distill_repository(
    *,
    path: Path,
    output_file: Path,
    level: int = 2,
    anchors: bool = True,
) -> Dict[str, Any]:
    """Distill *path* into *output_file* and return operation statistics."""

    start = time.time()

    tree = build_fs_tree(path, include_hidden=False)
    all_files = flatten_fs_tree(tree, prefix=path)

    map_file = output_file.with_suffix(output_file.suffix + ".map.json")

    distilled_parts: List[str] = []
    mappings: List[Dict[str, Any]] = []
    files_processed = 0
    current_line = 1  # 1-based mapping lines

    for fp in all_files:
        # Skip symlinks and the output / map artifacts
        if fp.is_symlink() or fp.resolve() in {
            output_file.resolve(),
            map_file.resolve(),
        }:
            continue

        # Skip files generated by CodeTag itself
        try:
            with fp.open("r", encoding="utf-8", errors="ignore") as check_f:
                if CODETAG_MARKER in check_f.readline():
                    continue
        except Exception:
            continue

        if fp.suffix.lower() not in SOURCE_CODE_EXTENSIONS:
            continue

        try:
            content = fp.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            continue
        if "\x00" in content:
            continue  # binary-like

        # ---------------- Distill ----------------
        distilled: Optional[str] = None
        if TREE_SITTER_AVAILABLE and distill_with_tree_sitter is not None:
            distilled = distill_with_tree_sitter(content, fp.suffix.lower(), level)

        if distilled is None:
            if level == 1:
                distilled = distill_level_1(content)
            elif level == 2 and fp.suffix.lower() == ".py":
                distilled = distill_level_2(content, include_anchors=anchors)
            else:
                distilled = distill_level_1(content)

        if not distilled:
            continue

        # ---------------- Assemble block ----------------
        sep = "=" * 50
        rel_path = fp.relative_to(path)
        block = "\n".join([sep, f"--- FILE: {rel_path} ---", sep, distilled, "\n"])
        distilled_parts.append(block)
        files_processed += 1

        content_lines = len(distilled.splitlines())
        mappings.append(
            {
                "distilled_range": [
                    current_line + 3,
                    current_line + 3 + content_lines - 1,
                ],
                "source_file": str(rel_path),
            }
        )
        current_line += 3 + content_lines + 2  # header (3) + body + footer (2)

    # ---------------------------------------------------------------- write
    final_output = f"{CODETAG_MARKER}\n\n" + "\n".join(distilled_parts)
    output_file.parent.mkdir(parents=True, exist_ok=True)
    output_file.write_text(final_output, encoding="utf-8")

    # ---------------------------------------------------------------- map
    from . import __version__  # canonical version

    map_file.write_text(
        json.dumps(
            {
                "codetag_version": __version__,
                "distillation_level": level,
                "source_root": str(path.resolve()),
                "mappings": mappings,
            },
            indent=2,
        ),
        encoding="utf-8",
    )

    # ---------------------------------------------------------------- stats
    try:
        encoding = tiktoken.get_encoding("cl100k_base")
        total_tokens = len(encoding.encode(final_output))
    except Exception:
        total_tokens = -1

    return {
        "files_processed": files_processed,
        "total_tokens": total_tokens,
        "map_file_path": map_file,
        "duration_seconds": round(time.time() - start, 2),
    }
